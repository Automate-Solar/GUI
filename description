General points:
We are going to build a GUI that will be used to set up, run and monitor a lab experiment. The experiment is controlled by pre-existing code called bertha_controller that the GUI should provide an entry point to. Via the GUI, an operator will provide settings to bertha_controller, call some of its functions and plot data generated by it.
The GUI will need to read and write some files from the local computer
The GUI will need to access a mongodb database 
The GUI should save some of its settings (e.g toggle button states, values in fields), and it should restore them from the saved state at startup. It can create its own configuration files for this purpose.
A dark theme should be used.
Imports: 
source_configuration as sc
workflow_control  as wc

Description of windows and operations of the GUI:
The entry point window for the GUI:
600x600 size
Background - generate an image evoking a utopian automated laboratory
Title: BERTHA self-driving laboratory
Three large buttons in the centre: “Enter self-driving workflow…”, “Run standard recipe…”, “System setup”
Clicking any of those buttons causes the entry point window to become inactive and opens a new window of the corresponding name. When they are closed, the entry point window can be active again.

“System setup” child window:
Contains a frame called “source setup”. This displays data from a set of lists found in sc. Each list has 6 entries, which are numerics or strings. The entries in the lists “materials”, “supplies”, “targets”, “max_powers” should be displayed, each list item in its own text field, with the text fields being laid out as a table, with each list forming a row. Row headers are the list names, column headers are “source 1”, “source 2”, up to “source 6”. 
Initially, the text fields are not editable.
Two buttons are placed below the table: “edit” and “close”. “Edit” makes the fields editable and the user can enter new values. “Close” closes the window. When clicking close, if the user has changed any entries, a popup should ask them to confirm if the changes should be kept or discarded, warning them that workflows using the old configuration will no longer be operable. The values in the lists in sc should be updated or kept, correspondingly. 

“Run standard recipe” child window:
Size 800x800
The leftmost 200 px is a frame called “process setup”, the rest is a frame called “recipe preview”.
The lower 100 px is reserved for two additional frames. On the left “Simulate and save”, which contains toggle controls “simulate” and “save”, assigned to bools of the same name. The right frame contains buttons “Run recipe” and “Cancel”.
The “process setup” frame contains:
a drop down selection box that contains a list of .txt files from the local folder “recipes”. The selected recipe should be used to define a filepath object.
Below that a field “presputter time” for numeric entry between 0 and 300 (units of seconds labelled to the right of the field), assigned to int “presputter_time”. 
A smaller frame called “QCMs”, containing two toggle buttons “use QCMs” (assigned to bool “use_qcms” and “minimise QCM exposure” (assigned to bool “min_qcm”). 
Below these tabs two are fields called “iterations” (for numeric entry) and “make samples” (a check box).  “Iterations can accept values from 1 up to a maximum value max_iterations. “Make samples” is assigned to a bool, and iterations to an int. 
 
The recipe preview frame is to be used to display a preview of the file selected in “process setup”. The file is formatted as a tab-separated table with headers). Scroll bars can be used to allow the full file to be viewable.
When any recipe file is selected, an existing function get_recipe_from_file(filepath) can be called which will return a dataframe, assigned to “recipe” and a list of six bools, assigned “active_sources”. 
The “run recipe” button will call a function “initialise_series”, passing “active_sources”, “recipe”, “use_qcms”, “min_qcm”, “iterations”, “presputter_time”)


“Enter self-driving workflow” child window
Size 800 x 1000
The contents of fields in the window should be saveable in “workflow definition” files (.txt files in the form of a dict).  
The topmost 100 px is used for several buttons: “load workflow…” and “new workflow…”. Until one of these is selected, the rest of the window should be non-editable.  
“Load workflow” should prompt the user to browse to a chosen workflow definition file with all values read from the file being loaded into the window’s fields. When loading a workflow definition file, the first entry (a list called “target_materials” should be compared to the existing values in sc.materials and if they are not the same, a popup should warn the user that “the current source configuration does not match the workflow definition”. In that case, the “run experiments” button should be inactive. 
The “new workflow” button should clear the contents of the fields in all tabs of the window in preparation for new values to be entered. It should create a pop-up window called “choose active sources” In this popup, there is a horizontal row of six toggle controls with titles “source 1”, “source 2” up to “source 6”. Underneath this row is a row of non-editable fields displaying values 1-6 from the lists sc.materials. The values of the toggle controls are assigned to a list of bools “active_sources”. There are two buttons called “create workflow” and “cancel”. When “create workflow” is clicked, if at least two True values are in active_sources, the window is closed and a new workflow definition file created (with user specified name). Otherwise the user is warned to choose at least two active sources. The first entry in the workflow definition file has key “target materials” and is given the list of values from “sc.materials”. The next key/value pair is “active_sources”.

The lower 100 px has three buttons “save workflow”, “run experiments” and “close”. “Save workflow” should cause all the contents of all fields in this window to be written to the workflow definition file. 
When the “close” button is clicked, the user should be prompted to confirm if changes will be saved to the workflow definition file, or if they should be discarded. 
The rest of the window is used to display a series of tabs (create 5, though some will be blank). The titles of the tabs provided in a list of strings called “workflow_stages”. The contents of the tabs will need to be saved in the current workflow definition file. All tabs apart from the first one are inactive until a certain condition is met in the previous tab. 
In the first tab, there is an editable table titled “targeted material compositions”. The column headers are defined by the corresponding values in sc.materials for which “active_sources” is True. The row headers are numerics 1, 2, 3. Eight rows are available. The other fields of the table have default values of 0. A corresponding dataframe is created with initially zero rows but the same headers. 
The user can enter positive integer values in the table’s fields. Each row has a button “fix target” at its end. When clicked, if there are non-zero values in at least two the row’s boxes, a popup asks the user to confirm (with an OK button) and the row’s contents are saved to the dataframe, which is written to the workflow definition file. The row is no longer editable after this time, even after reloading the workflow definition file.  
The next tab becomes active once at least one dataframe entry has been made. 



